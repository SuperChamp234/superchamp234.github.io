<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Eleventy v1.0.2">
    
    
    <meta name="description" content="notes and thoughts as I break things">
    
    <title>Accelerating Sparse Matrix Multiplication on FPGAs</title>

    <link rel="stylesheet" href="/css/css.css">
    <script data-goatcounter="https://zainsv.goatcounter.com/count"
        async src="/js/count.js"></script>
</head>
<body>
    <a href="/">back</a>

<article>
  <p class="post-meta">
    <time datetime="Mon Aug 28 2023 12:37:53 GMT+0000 (Coordinated Universal Time)">2023-08-28</time>
  </p>
  
  <h1>Accelerating Sparse Matrix Multiplication on FPGAs</h1>
  
  <p>Sparse matrix multiplication (SpGEMM) is a fundamental operation in scientific computing, graph analytics, and machine learning. However, its irregular memory access patterns and high computational complexity make it challenging to accelerate efficiently. In this project, I explored FPGA-based acceleration for SpGEMM using High-Level Synthesis (HLS), focusing on different dataflows and sparse storage formats to optimize performance.</p>
<p>Sparse matrix multiplications differ from dense operations due to the need to handle zero values efficiently. The major challenges include:</p>
<ul>
<li>
<p>Memory Bottlenecks: Storing and accessing sparse data without excessive overhead.</p>
</li>
<li>
<p>Parallelization Issues: Exploiting FPGA parallelism despite the irregularity of sparse data.</p>
</li>
<li>
<p>Storage Format Efficiency: Choosing between formats like Compressed Sparse Row (CSR) and Compressed Sparse Column (CSC) to optimize access patterns.</p>
</li>
</ul>
<p>To address these challenges, I implemented and compared multiple SpGEMM dataflows on an FPGA:</p>
<ul>
<li>
<p>Inner Product Dataflow: Computes the dot product of corresponding rows and columns but suffers from low parallelism.</p>
</li>
<li>
<p>Outer Product Dataflow: Generates partial results for each outer product but requires significant on-chip memory.</p>
</li>
<li>
<p>Row-based Dataflow: Optimizes memory access but can limit computation throughput.</p>
</li>
</ul>
<p>I implemented SpGEMM on an FPGA using Vivado HLS, targeting the Xilinx Arty A7 board. While the implementation showed promising potential, a few challenges arose. There was an issue with understanding how the AXI master interface works, leading to incorrect mem access. This was my first HLS project, but since the Arty A7 lacked an SoC, it was not possible to run a full application on the FPGA.</p>
<p>For a deeper dive into the design, implementation, and challenges, check out the full paper <a href="https://drive.google.com/file/d/1_hl6ta7lshTdV9dNm-zLNECsfylJ96QZ/view?usp=drive_link">here</a>. If you have any insights or suggestions, feel free to reach out—I’d love to discuss optimizations for sparse computations on FPGAs!</p>

</article>
</body>
</html>
